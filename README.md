Next Dapp is in its alpha releases. Things are to change substantially before it reaches stable versions.

We will call Next Dapp powered apps **nDapps** throughout this documentation.

This repository is a collection of example usages and not the Next Dapp itself.

---

If you would like to develop Next Dapp itself, these are the main repositories to follow.

* Next Dapp CLI Tool [nextdapp](https://github.com/warashibe/nextdapp) including a Bare Minimum App [nd-bare](https://github.com/warashibe/next-dapp-bare)

  A command line tool to handle project generation and plugin management.


* Next Dapp Core [nd-core](https://github.com/warashibe/nd-core)

  This is the core plugin which includes a state management system heavily based on [recoil](https://recoiljs.org/).


* Next Dapp Plugin Base [nd-base](https://github.com/warashibe/nd-base)

  Clone `nd-base` if you would like to develop your own plugin.

---
If you would like to develop your own app (nDapp), follow the instructions below.

# Prerequisite

To develop nDapps, you might as well familiarize yourself with these tech stacks.

### Must-have Knowledge
* [React](https://reactjs.org/) ([Tutorial](https://reactjs.org/tutorial/tutorial.html))
* [Next.js](https://nextjs.org/) ([Tutorial](https://nextjs.org/learn/basics/create-nextjs-app))

### Optional yet Desirable Knowledge
* [Firestore](https://firebase.google.com/docs/firestore)
* [Recoil](https://recoiljs.org/)
* [Ramda](https://ramdajs.com/)
* [Rebass](https://rebassjs.org/)
* [web3.js](https://web3js.readthedocs.io/en/v1.2.9/)

---

# Setup

## Install Next Dapp CLI Tool globally

```bash
yarn global add nextdapp
```

or

```bash
sudo npm i -g nextdapp
```

## Create an nDapp project and install node packages

```bash
nextdapp create myapp
cd myapp
yarn
```

## Copy and modify `conf.js` configuration file

```bash
cp nd/conf.sample.js nd/conf.js
```

## Run the app locally

```bash
yarn dev
```

Now you can access the app via [http://localhost:3000](http://localhost:3000).

---

# nDapp Structure

Next Dapp is built on top of [Next.js](https://nextjs.org) which is based upon [React](https://reactjs.org). You can develop nDapps in the same way you develop Next.js apps.

```
.
├── pages/
│   ├── api/
│   └── index.js
├── public/
│   └── static/
│       ├── images/
│       ├── favicon.ico
│       └── manifest.json
├── lib/
│   ├── init.js
│   ├── custom.js
│   └── sw.js
├── firebase/
│   ├── firestore.rules
│   ├── firestore.index
│   └── functions/
│       └── env.json
├── nd/
│   ├── core/
│   │   └── Conf.js
│   ├── conf.js
│   ├── conf.local.js
│   ├── atoms.js
│   ├── funcs.js
│   ├── bind.js
│   ├── Tracker.js
│   ├── .nextdapp.js
│   ├── .nextdapp-props.js
│   └── .plugins.json
├── node_modules/
├── .gitignore
├── .nowignore
├── .env
├── package.json
├── next.config.js
├── now.json
└── jscofig.json

```

## Notable Files

### `jsconfig.json`

This file defines the app root directory as `baseUrl`, which allows you to `import` with relative paths without a prefix from the root directory. For instance, the app configurations located at `nd/conf.js` can be imported like this.

```javascript
import conf from 'nd/conf'
```

### `nd/`

Next Dapp specific files go into `nd` directory. 

### `nd/conf.js` `nd/conf.local.js`

The only files you should modify are `nd/conf.js` and `nd/conf.local.js`. The settings in `nd/conf.js` will be overridden by the settings in `conf.local.js`. Don't touch the other files in the `nd` directory.

### `nd/[plugin-name]/[component-name].js`

Plugin specific components are automatically installed under `nd/[plugin-name]/[component-name].js`.

For instance, you can `import` and use `nd/core/Conf.js` compoent from `@nextdapp/core` plugin as shown below.

```javascript
import Conf from `nd/core/Conf`
export default () => <Conf />
```

### `nd/.nextdapp.js` `nd/.nextdapp-props.js` `nd/.plugins.js`

These files are auto-generated by `nextdapp` CLI Tool. Do not ever touch these.

### `nd/bind.js`

This is used to conveniently bind a `react` component with `recoil` atoms and functions. `atoms` are globally reactive props which are predefined in plugins or your custom `lib/init.js` file. `reactive` means if a value is changed every component that uses the value will be rerendered. This is not easy to do globally but Next Dapp efficiently handles it with `recoil` state management library.

Functions need to be initialized inside the component as shown below. Atoms will be passed as component props.

```javascript
import bind from `nd/bind`
export default bind(({ atom1, atom2, init, set }) => {
  const { func1, func2 } = init()
  return <div>{props.prop1}</div>
},["atom1", "atom2", "func1", "func2"])
```

### `nd/Tracker.js`

This is a global state tracking Component. By inserting `Tracker` like below anywhere in your app, you can watch global states (Recoil atoms/selectors) and reactively execute a function when watching states change. This isn't easy to do without external state management libraries and complex setups, but Next Dapp makes it a breeze out of the box.

```javascript
<Tracker
  name="count_tracker"
  type="any"
  watch={["count", "count2", "count3"]}
  props={["count", "count2", "count3"]}
  func={({ set, props: { count, count2, count3 } }) => {
    set(count * count2 * count3, "product")
  }}
  />
```


### `lib/init.js`

Define yoru custom reactive `atoms` here. You can bind these values to react components and reactively use them.

```javascript
export default {
  count: 0,
  obj: {}
}
```

### `lib/custom.js`

Define yoru custom functions here. You can bind these functions to react components use them with reactively changable atoms.


```javascript
export const addCount = [
  ["count"], // specify atoms to use in the function
  async ({ set, conf, values }) => {
    set(values.count + 1, "count") // set can reactively change the value of atoms
  }
]
```

### `.env`

Use `.env` to define credentials which shouldn't be exposed in the client app. Don't write these credentials in `nd/conf.js` or `nd/conf.local.js`. The data in these files will be inlined and exposed in the production app. In `Next.js` apps, there are places only executed on the server side, where you can use credentials without exposing them such as `pages/api`, `getStaticProps`, `getStaticPaths` and `getServerSideProps`.

### `firebase/`

The `firebase/` directry is only needed, if you install plugins which requrie `Firestore` and `Functions`. [@nextdapp/account](https://github.com/warashibe/nd-account) is one of such plugins. Use `firebase/functions/env.json` to define credentials for Cloud Functions.

---

# Install Plugins

In nDapps, everything is a plugin. Use `nextdapp add [plugin-name]` and `nextdapp remove [plugin-name]` to add/remove plugins.

These commands install/uninstall a node package and place/displace necessary files in the app tree.

The official plugins are scoped under `@nextdapp` in npm registry.

```bash
nextdapp add @nextdapp/util
```

```bash
nextdapp remove @nextdapp/util
```

## Available Plugins

### [@nextdapp/core](https://github.com/warashibe/nd-core)

`core` is a must-have plugin for nDapps. It's pre-installed.

### [@nextdapp/util](https://github.com/warashibe/nd-util)

`util` plugin provides handy little functions you may or may not need.

### [@nextdapp/firebase](https://github.com/warashibe/nd-firebase)

`firebase` enables Firestore database integration.

### [@nextdapp/account](https://github.com/warashibe/nd-account)

`account` enables user management via Firebase Authentication.

### @nextdapp/nav (coming soon)

`nav` contains a highly customizable and responsive navigation component.

### @nextdapp/web3 (coming soon)

`web3` integrates Metamask and Authereum smart contract wallet.

### @nextdapp/wallet (coming soon)

`wallet` manages ethereum addresses of the app users.

### @nextdapp/uniswap (coming soon)

`uniswap` integrates Uniswap DEX.

### @nextdapp/dev (coming soon)

`dev` integrates Dev Protocol.

### @nextdapp/editor (coming soon)

`editor` is an developer friendly editor with markdown and Ace coding editor combined together.

### @nextdapp/blog (coming soon)

`blog` is a simple CMS (content management system).

### @nextdapp/ifps-blog (coming soon)

`ipfs-blog` is a CMS where data is stored in IPFS and accessed with ehtereum private keys.

---

# A simple page tutorial

Modify `page/index.js` for this super quick tutorial. What you usually do when developing an app are...

* Define global states (atoms) in `/lib/atoms.js`
* Define custom functions in `/lib/custom.js`
* Bind atoms and functions to page components
* Use `/nd/Tracker` component to watch state changes and execute functions accordingly
* Install plugins for predefined functions.

## Hello, world!

The simplest `Next.js` app would look like this.

```javascript
// /pages/index.js

export default () => <div>Hello, world!</div>

```

## bind / set / init

`set( [value], [atom-key] )` can set and change global states (`atoms`).

The app below binds the page component with redux state `myname` and initially set it `John` with `useEffect` (react hook). Functions need to be initialized with `init()` inside the component for reactivity.

```javascript
import bind from "nd/bind"
import { useEffect } from "react"

export default bind(
  ({set, init, myname}) => {
    const { setName } = init()
    useEffect(()=>{
	  set("John", "myname")
	  setYourName("Alis")
	}, [])
    return <div>Hello, {myname}!</div>
  },
  ["myname", "setYourName"] // you can mix predefined atoms and functions in the same array
)

```

## selector

You can also set `recoil` [selectors](https://recoiljs.org/docs/basic-tutorial/selectors/) via `bind`.

Pass an object with a key as a selector name and the value with a `get` function to reactively compute the selector value. `async` selectors will only work with `React Concurrent Mode`. You need to install `react@experimental` and `react-dom@experimental` for that. I reccomend you use `Tracker` component explained below to reactively compute compound states and execute functions instead of `async` selectors for now.

```javascript
import bind from "nd/bind"
import { useEffect } from "react"

export default bind(
  ({set, init, myname, ourname}) => {
    const { setName } = init()
    useEffect(()=>{
	  set("John", "myname")
	  setYourName("Alis")
	}, [])
    return <div>Hello, {ourname}!</div>
  },
  [
    "myname",
    "setYourName",
	{
      ourname: {
        get: atoms => ({ get }) => `${get(atoms.myname)} : ${get(atoms.yourname)}`
      }
    }
  ]
)
```

## Custom functions

An nDapp is basically a Next.js app, so you can do whatever you like outside of the `nd/` directory.

Plugins come with lots of predefined states and functions, but you can also define your own custom functions and globally share and use them by binding to page components.

We recomend to use `lib/custom.js` to define custom functions.

Custom functions will automatically get four arguments.

`set` is a function to set redux states.

`props` is all the current values of watched atoms. For instance `props.myname` would be `John`.

`conf` is the app configurations defined in `nd/conf.js` and `nd/conf.local.js`.

`val` is the values passed to this function as arguments.

A function definition needs to be an Array with the first argument being the name of atoms to use inside the function which is passed as the second argument. In the example below, only `myname` will be passed to the function as as a part of `props`.

```javascript
// lib/custom.js
export const set_dogsname = [
  ["myname"], // states to pass to the function props
  async ({ set, props, conf, val : { name } }) => { // custom function
    console.log(`My name is ${props.myname}.`)
    set(name, "dogsname")
  }
]
```

The functions defined in `lib/custom` will be automatically exported via `nd/funcs.js`, but if you use other files you need to merge and export from `nd/funcs.js`.


```javascript
// /nd/funcs.js
import { mergeAll, mapObjIndexed } from "ramda"
import { useRecoilCallback, useRecoilState, atom } from "recoil"
import { default as atoms } from "./atoms"
import _func from "core/func"
import conf from "nd/conf"

const func = _func({ useRecoilCallback, useRecoilState, atoms, conf, atom })
import * as _epics from "nd/.nextdapp"
import * as custom from "lib/custom"

const predefined = mapObjIndexed((v, k, o) => func(v[0], v[1]))(_epics)
const custom_epics = mapObjIndexed((v, k, o) => func(v[0], v[1]))(custom)
export const funcs = mergeAll([predefined, custom_epics])
```

## Custom global states (Recoil atoms)

If you need your own redux states, you are free to define them in a similar manner you define custom functions above.

1. use any file you want (`/lib/init.js` recommended) to export initial state values.
2. import them in the `/nd/atoms.js`.
3. merge them with `init` and export from `/nd/atoms.js`.

The atoms defined in `/lib/init.js` are automatically exported from `/nd/atoms.js`.

```javascript
// /lib/init.js
export default {
  myname: "Bob,
  yourname: "Alis
}
```


```javascript
// /nd/atoms.js
import { atom } from "recoil"
import { o, mergeLeft, mapObjIndexed } from "ramda"
import init from "nd/.nextdapp-props"
import core from "lib/init"

const _init = o(
  mapObjIndexed((v, k) =>
    atom({
      key: k,
      default: v
    })
  ),
  mergeLeft(core)
)(init)
export default _init

```
## Use custom functions and states (atoms) in a page component

Once you defined custom `epics` and `states`, you can bind them to any page components.

```javascript
import bind from "nd/bind"
import { useEffect } from "react"

export default bind(
  ({ set, myname, yourname, dogsname, init }) => {
    const fn = init() // functions need to be initialized inside the component
    useEffect(() => {
      fn.set_dogsname("Pochi")
    }, [])
    return (
      <div>
        Hello, {myname} from {yourname}! I have a dog named {dogsname}.
      </div>
    )
  },
  ["myname", "yourname", "dogsname", "set_dogsname"] // you can mix atoms and functions here
)
```
## Reactively tracking global states (atoms) with `Tracker`

You can insert `Tracker` anywhere in your page components. `Tracker` doesn't render anything to the UI.

You can `watch` state changes in two ways.

type `all`: the function executes after **all** the specified states changed.

type `any`: the function executes when **any** one of the specified states changed.

The function defined as `func` is the same as custome functions explained above. You can change any global states using `set`. The function can be `async` and you can change any global states even if they are not bound to the component.

Only the states specified in the `props` array will be passed to the functions as `props`. You may need different states than `watch` in the function `props`.

```javascript
import Tracker from "nd/Tracker"
import bind from "nd/bind"
export default bind(
  ({ product }) => { // this is a component
    return (
      <div>
        <Tracker
          name="count_tracker" // a unique name of the tracker
          type="any" // tracking type: any or all
          watch={["count", "count2", "count3"]} // state changes to watch
          props={["count", "count2", "count3"]} // states to pass to the function below
          func={({ set, props: { count, count2, count3 } }) => { // the function to execute
            set(count * count2 * count3, "product")
          }}
        />
        <div>count * count2 * count3 = {product}</div>
      </div>
    )
  },
  ["product"] // bind and track states to use inside the Component
)
```

## Using plugins

Next Dapp plugins can add predefined `states`, `functions`, `Components`, `apis` and cloud `functions` to the app.

Let's install and use `@nextdapp/web3` plugin to enable `web3` capabilities through `Metamask` and `Authereum` smart contract wallet. With this plugin, you will be able to handle blockchain transactions and cryptocurrency.

### Install the plugin (web3 plugin is not up to date at this moment)

From the app root directry,

```bash
nextdapp add @nextdapp/web3
```

plugin specific `states` and `functions` are namespaced. For instance, `@nextdapp/web3` predefineds redux `states` like `eth_selected$web3`, `address_in_use$web3`, `user_balances$web3` and so forth. To hook the app with ethereum wallets, it has `hookWeb3$web3` function predefined. The predefined `Components` can be exported via `nd/web3` directory.

Refer to the plugin document for the details.

The simplest way to connect with one of these wallets is to use the `Status` component from `@nextdapp/web3`.

Add plugin required configurations to `nd/conf.js` or `nd/conf.local.js`.

`@nextdapp/web3` requires an ethereum network id to be specified.

`1` is for mainnet and `3` is for Ropsten testnet.

```javascript
// nd/conf.local.js
module.exports = {
  web3: {
    network: "3"
  }
}
```

```javascript
import bind from "nd/bind"
import { useEffect } from "react"
import { Status } from "nd/web3/Status"

export default bind(
  props => {
    const fn = props.init()
    useEffect(() => {
      fn.hookWeb3$web3()
    }, [])
	console.log(props)
    return <Status />
  },
  [
    // predefined states (atoms)
    "eth_selected$web3",
	"address_in_use$web3",
	"auth_selected$web3",
	
	// predefined functions
	"hookWeb3$web3"
  ]
)
```
